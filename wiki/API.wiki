#summary Everything you need to know about the circulate API.

== Design Notes ==

our main package will use *library.circulate*

we plan to support only the Flash Player and AIR client<br>
(maybe a redtamarin command line client later)

we want to be "cross-platform" in the sens that if it can work under Linux<br>
then we will make our best effort to keep it compatible for Linux runtimes<br>
(eg. AIR 2.6, projector with a standalone player 11.2, and Flash Player 11.6 for the browser)<br>
this could involve special "hooks" like conditional compilation etc.


We are directly influenced by the design of the RTMFP API<br>
and should be aware of that at all time.

It should be possible to have more than one Network running in parallel,<br>
but it is not high in the priorities of the API.

It have to be possible to have numerous Nodes running in parallel.

We need to define different types of Nodes for specialised uses:
  * sending/receiving commands
  * sharing files
  * interactive (real-time, no latency) connections
  * broadcast (some latency) connections

We need to define different types of Commands,<br>
and define a default mechanism to transfer those commands<br>
and serialize/deserialize them.

We want to minimize the use of the term "P2P" in favour of more generic terms;<br>
for ex: favour `LocalNetworkArea` over `P2PLocalNetwork`

=== General ===

A *!NetworkSystem* connect/disconnect to a network.

A *!NetworkNode* allows to organise groups inside the network.

A *!NetworkClient* is the user attached to the group.

A *!NetworkSystem* contains at least one *!NetworkNode* or more.

A *!NetworkNode* contains at least one *!NetworkClient* or more.

By default, the *!NetworkSystem* and any *!NetworkNode* always share one local client reference.

=== Command Center ===

The *Command Center* is a special type of *!NetworkNode*.

As soon as a *!NetworkSystem* creates a *!NetConnection*<br>
the system creates by default the *!CommandCenter*.

When a *!NetworkSystem* disconnects we keep the *!CommandCenter* reference in memory.

A *!NetworkClient* can not create or destroy the *!CommandCenter*.

The *!CommandCenter* always use the same *!NetGroup* name and *!GroupSpecifier*.

We wire all the *!NetworkCommand* trough the *!CommandCenter* (hence the name).

Even if a *!NetworkClient* is always connected to The *!CommandCenter* it can still be invisible to other clients.

Only an admin client can broadcast messages to every single connected *!NetworkClient* (invisible or not)<br>
trough the *!CommandCenter*, but it does not mean that an admin can see an invisible client.

A *!NetworkSystem* is meant to work with the same *!CommandCenter*,<br>
you can not use more than one *!CommandCenter*<br>
but for your own need you can rename it to any name you want.

By default we use this name "library.circulate.commandcenter".

The *!CommandCenter* is structured in such a way
  * to work almost like a *!ChatNode* but it is not a *!ChatNode*
  * to send commands as fast as possible
  * to scale up to 1000s of clients
  * to sync/announce/expire/update/etc. all connected clients
  * to sync/announce/expire/update/etc. all existing nodes
  * to serve list of known clients (not invisible client)
  * to serve list of known nodes (not invisible node)
  * to broadcast to all known clients (invisible included)
  * to broadcast to all known nodes (invisible included)
  * etc.

scenario:<br>
when 2 clients want to chat in a private node<br>
the command center allows to connect those 2 clients<br>
even if they are in different nodes and not connected to each other.<br>
In this case, the command center can do the invitation, introduction, sync, etc.


we can visualise the command center on a ring<br>
http://circulate.googlecode.com/svn/gfx/commandcenter_visualisation_test.png


=== Sharing Files ===

*scenario:* simple file sharing using a Node per file

using commands *!AnnounceFile*/*!RequestFile*
  # user A announce he got `file_123.mp4` (send trough command center)
  # this create a node !OneFileNode with the name of the file
  # user A become a seeder on this node
  # user B request `file_123.mp4` (again trough command center)
  # user B become a leecher on this node
   
*pros:*
  * because the node share only one file<br>it simpler to have `chunk[0]` containing the metadata of the file<br>and split the file in chunks
  * the file does not necessary need to be loaded in memory<br>it could be pre-sliced on the hard drive
    {{{
          eg. files/
                |_ file_123.mp4
              shared/
                |_ file_123.mp4/
                       |_ 0
                       |_ 1
                       |_ 2
                       |_ ...
    }}}
  * we can also have the option to contains the file data in memory<br>this depends on the memory of the client<br>eg. for desktop no problem to share few gigs<br>for mobile not an option

*cons:*
  * we need one node per file<br>going trough an adobe cirrus server<br>it could limit the max number of file shared
  * it share only one file<br>so we need a file manager on the side to manage list of files
       
       
*misc:*<br>
on top of *!AnnounceFile*/*!RequestFile*<br>
we could also use *!HaveFile* and *!FileList* commands<br>

*!HaveFile* would be to announce a file we have on the hard drive<br>
but already shared in a node<br>
if someone request the file then we can then Announce the file<br>
and start to share it<br>
       
*!FileList* would allow to share list of files we can share<br>
without creating any node in the first place<br>

the difference is<br>
*!AnnounceFile* is for telling others we have a file ready to share<br>
eg. either pre-sliced on the HDD or loaded in memory<br>
in both case the node sharingthe file is already created<br>
and wait for others (user using !RequestFile) to connect to the node<br>
while<br>
*!HaveFile* is for telling others that we have the file available<br>
but it is not ready to share as the node to share the file is not created yet<br>
and by extension we didn't already pre-sliced or loaded the file in memory<br>

see it like that<br>
<br>
*!HaveFile* and *!FileList* are for transferring big number of files<br>
without overloading the memory or the hard drive<br>
it's for archive<br>
eg. I let you know that all this is available if you need it<br>
       
*!AnnounceFile* and *!RequestFile* are for transferring a pre-known number<br>
of files right away, eg. ready to connect and to share<br>
it's for real time update right now<br>
best example is for the updating the assets of an application<br>

example:<br>
multiplayer game with 50 different character animation<br>
by default you embed in the app only 1 generic character (eg. 50MB limit on mobile)<br>
if you're solo on the network you downloading the others 49 characters from a server<br>
when others join the network you cna share with them all or some of the already downloaded<br>
characters, on a local network it would speed up a LOT the download process<br>
in general it would put less load on your server or simply not use a server at all.

<br>
<br>

== Dependencies ==

*!NetConnection*:<br>
creates a two-way connection between a client and a server.

*!NetGroup*:<br>
represents membership in an RTMFP group.

*!NetStream*:<br>
 opens a one-way streaming channel over a !NetConnection.

*!GroupSpecifier*:<br>
 is used to construct the opaque `groupspec` strings<br>
that can be passed to !NetStream and !NetGroup constructors


<br>
<br>

== Vocabulary ==

*Network*:<br>
is responsible for creating, connecting and managing Nodes and Clients.<br>
Can be associated with only one !NetConnection.<br>


*Node*:<br>
act as a super !NetGroup (or a "super group")<br>
but contains different objects and references.<br>
The Node is responsible to make all those different<br>
objects work with each other: !NetGroup, !GroupSpecifier, Clients, etc.
Can be associated with only one Network.<br>
Can be associated with only one !NetGroup or one !NetStream.<br>

*Client*:<br>
lets you handle each user, or client, connection to a RTMFP Network.<br>
The Network automatically creates a Client object when a user connects to it.

*Peer ID*:<br>
Each Client has a peer ID, and the peer ID space is server-specific.<br>
The peer ID is the SHA256 of the client's Diffie-Hellman public key.<br>

*Command*:<br>
Network Commands are used as "control protocol" over the Network.<br>

*Packet*:<br>
A low-level message transfered over the network<br>
which allows to transport a Command in such a way<br>
it can be automatically serialized/deserialized ( using AMF and !ByteArray).

*Message*:<br>
!ActionScript message serialized in AMF.<br>
The message can be one of the following types: an Object, an int, a Number, or a String.<br>
The message cannot be a MovieClip.



*Ring*: (see [http://en.wikipedia.org/wiki/Network_topology#Ring wikipedia])<br>
<pre>
A network topology that is set up in a circular fashion in which data travels around the
ring in one direction and each device on the right acts as a repeater to keep the signal
strong as it travels. Each device incorporates a receiver for the incoming signal and a
transmitter to send the data on to the next device in the ring. The network is dependent
on the ability of the signal to travel around the ring. When a device sends data, it must
travel through each device on the ring until it reaches its destination. Every node is a
critical link.
</pre>

*Node ring*:<br>
Visual representing the Node as a circle.

*Ring Position*:<br>
In our case, the ring topology is applied to the Clients connected to a particular Node;<br>
so the ring position would be then the position of a client "address" on a circle representing the Node (the Node ring).


*Command Center*:<br>
Special Node responsible for receiving and dispatching network commands.