#summary Everything you need to know about the circulate API.

== Design Notes ==

our main package will use *library.circulate*

we plan to support only the Flash Player and AIR client<br>
(maybe a redtamarin command line client later)

we want to be "cross-platform" in the sens that if it can work under Linux<br>
then we will make our best effort to keep it compatible for Linux runtimes<br>
(eg. AIR 2.6, projector with a standalone player 11.2, and Flash Player 11.6 for the browser)<br>
this could involve special "hooks" like conditional compilation etc.


We are directly influenced by the design of the RTMFP API<br>
and should be aware of that at all time.

It should be possible to have more than one Network running in parallel,<br>
but it is not high in the priorities of the API.

It have to be possible to have numerous Nodes running in parallel.

We need to define different types of Nodes for specialised uses:
  * sending/receiving commands
  * sharing files
  * interactive (real-time, no latency) connections
  * broadcast (some latency) connections

We need to define different types of Commands,<br>
and define a default mechanism to transfer those commands<br>
and serialize/deserialize them.

We want to minimize the use of the term "P2P" in favour of more generic terms;<br>
for ex: favour `LocalNetworkArea` over `P2PLocalNetwork`

=== General ===

A *NetworkSystem* connect/disconnect to a network.

A *NetworkNode* allows to organise groups inside the network.

A *NetworkClient* is the user attached to the group.

A *NetworkSystem* contains at least one *NetworkNode* or more.

A *NetworkNode* contains at least one *NetworkClient* or more.

By default, the *NetworkSystem* and any *NetworkNode* always share one local client reference.

=== Command Center ===

The *Command Center* is a special type of *NetworkNode*.

As soon as a *NetworkSystem* creates a *NetConnection*<br>
the system creates by default the *CommandCenter*.

When a *NetworkSystem* disconnects we keep the *CommandCenter* reference in memory.

A *NetworkClient* can not create or destroy the *CommandCenter*.

The *CommandCenter* always use the same *NetGroup* name and *GroupSpecifier*.

We wire all the *NetworkCommand* trough the *CommandCenter* (hence the name).

Even if a *NetworkClient* is always connected to The *CommandCenter* it can still be invisible to other clients.

Only an admin client can broadcast messages to every single connected *NetworkClient* (invisible or not)<br>
trough the *CommandCenter*, but it does not mean that an admin can see an invisible client.

A *NetworkSystem* is meant to work with the same *CommandCenter*,<br>
you can not use more than one *CommandCenter*<br>
but for your own need you can rename it to any name you want.

By default we use this name "library.circulate.commandcenter".

The *CommandCenter* is structured in such a way
  * to work almost like a *ChatNode* but it is not a *ChatNode*
  * to send commands as fast as possible
  * to scale up to 1000s of clients
  * to sync/announce/expire/update/etc. all connected clients
  * to sync/announce/expire/update/etc. all existing nodes
  * to serve list of known clients (not invisible client)
  * to serve list of known nodes (not invisible node)
  * to broadcast to all known clients (invisible included)
  * to broadcast to all known nodes (invisible included)
  * etc.

scenario:<br>
when 2 clients want to chat in a private node<br>
the command center allows to connect those 2 clients<br>
even if they are in different nodes and not connected to each other.<br>
In this case, the command center can do the invitation, introduction, sync, etc.




<br>
<br>

== Dependencies ==

*!NetConnection*:<br>
creates a two-way connection between a client and a server.

*!NetGroup*:<br>
represents membership in an RTMFP group.

*!NetStream*:<br>
 opens a one-way streaming channel over a !NetConnection.

*!GroupSpecifier*:<br>
 is used to construct the opaque `groupspec` strings<br>
that can be passed to !NetStream and !NetGroup constructors


<br>
<br>

== Vocabulary ==

*Network*:<br>
is responsible for creating, connecting and managing Nodes and Clients.<br>
Can be associated with only one !NetConnection.<br>


*Node*:<br>
act as a super !NetGroup (or a "super group")<br>
but contains different objects and references.<br>
The Node is responsible to make all those different<br>
objects work with each other: !NetGroup, !GroupSpecifier, Clients, etc.
Can be associated with only one Network.<br>
Can be associated with only one !NetGroup or one !NetStream.<br>

*Client*:<br>
lets you handle each user, or client, connection to a RTMFP Network.<br>
The Network automatically creates a Client object when a user connects to it.

*Peer ID*:<br>
Each Client has a peer ID, and the peer ID space is server-specific.<br>
The peer ID is the SHA256 of the client's Diffie-Hellman public key.<br>

*Command*:<br>
Network Commands are used as "control protocol" over the Network.<br>

*Packet*:<br>
A low-level message transfered over the network<br>
which allows to transport a Command in such a way<br>
it can be automatically serialized/deserialized ( using AMF and !ByteArray).

*Message*:<br>
ActionScript message serialized in AMF.<br>
The message can be one of the following types: an Object, an int, a Number, or a String.<br>
The message cannot be a MovieClip.



*Ring*: (see [http://en.wikipedia.org/wiki/Network_topology#Ring wikipedia])<br>
<pre>
A network topology that is set up in a circular fashion in which data travels around the
ring in one direction and each device on the right acts as a repeater to keep the signal
strong as it travels. Each device incorporates a receiver for the incoming signal and a
transmitter to send the data on to the next device in the ring. The network is dependent
on the ability of the signal to travel around the ring. When a device sends data, it must
travel through each device on the ring until it reaches its destination. Every node is a
critical link.
</pre>

*Node ring*:<br>
Visual representing the Node as a circle.

*Ring Position*:<br>
In our case, the ring topology is applied to the Clients connected to a particular Node;<br>
so the ring position would be then the position of a client "address" on a circle representing the Node (the Node ring).


*Command Center*:<br>
Special Node responsible for receiving and dispatching network commands.