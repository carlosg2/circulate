#summary misc.

== found in cirrus FAQ ==

{{{
Developers will need to provide a mechanism for exchanging peer identities
between instances of application through their own intermediary
(e.g., using HTTP web services, XML sockets to a presence server, etc.).
}}}

even if RTMFP provide a lot of things, there is no mechanism to remember<br>
for ex a user name and associate it with a peerID, it would be nice to provide that.

== found in forums etc. ==

{{{
> Cirrus will only bootstrap 16 groups per NetConnection.
}}}
so max 16 active groups per network ?

{{{
> Codename Cirrus currently has no limit to the number of connections per developer key.
> we ask that you let us know if you'll exceed 10,000 concurrent connections for purposes
> of resource & capacity planning.
}}}
would be good to know what is the hardware/bandwidth spec of this server

{{{
> there should be an event eventually, after a 90-ish second timeout.
> if you enter a completely invalid peer ID (not composed entirely of hex digits,
> not an even number of digits), you'll get an error event almost immediately. 
> if the peer ID isn't exactly 64 hex digits long, it won't work, because peer IDs
> are currently always 64 digits (256 bits) long.  however, it still tries,
> so you'll get the error event after the timeout.
}}}

{{{
> sendToAllNeighbors can send any AMF serializable object, including ByteArray
> (or Object, with ByteArray properties, if you want). 
> so can (NetGroup.) sendToNearest, sendToNeighbor, post, writeRequestedObject, and NetStream.send.
> you might need to set the NetConnection's defaultObjectEncoding to AMF3 (flash.net.ObjectEncoding.AMF3)
> to be able to use ByteArray (since that doesn't exist in AMF0).
}}}

{{{
> object replication is designed and tuned for fully reliable and reasonably
> fair diffusion of large amounts of data.  it is not tuned for real-time distribution.
> the "recompute which neighbors have what data" timer fires every 10 seconds,
> which is what you're observing.
> the 10 second timer duration is compiled into RTMFP and can't be changed from ActionScript.
> if you require full reliability but you also want timely delivery,
> and only one peer is sending data, you could do a hybrid of P2P multicast
> (with NetStream.send()) and object replication. you could do a removeWantObjects()
> on receiving the data over multicast, and maybe delay doing an addHaveObjects()
> of the new sequence numbers for at least the multicast window duration + relay margin
> duration to try to avoid duplicating data on the network.
}}}

{{{
> if you're using a NetGroup posting and/or multicast,
> you can set a password for using those functions.
> you then have two groupspecs:
> the groupspecWithAuthorizations, which you give to the "master peer"
> and which allows it to use those functions,
> and the groupspecWithoutAuthorizations,
> which you give to all non-master peers
> and which allows them to receive postings and/or multicasts
> but not send/publish.
}}}
allow to create chat room with an *op* who can kick/ban, create shared files protected by passwords etc.

Now we need to be able to pass this password around in a secure way (encryption),<br>
see if we can reuse the nonce of a specific connection


{{{
> peer IDs are cryptographically pseudorandom and are evenly distributed
> between 0000000000000000000000000000000000000000000000000000000000000000
>      and ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff.
}}}

so this is the range of peerID

{{{
> the NetConnection.farID is the ID of the RTMFP server to which you're connected. 
> the NetStream.farID of the subscribing/playing peer should match
> the NetConnection.nearID of the publishing peer.
> on the publishing end, the publishing NetStream has a property "peerStreams",
> which contains a separate NetStream for each connected subscribing peer.
> a member of that array will have a farID that matches the nearID of the subscribing peer.
}}}

so what happen when we connect serverless ? no farID for the netconnection ?

and for netstream, if we keep a list of "known peerID", we should be able to know<br>
who is connected to which streams

{{{
> the maximum number of DIRECT_CONNECTIONS NetStreams in one NetConnection
> is controlled by NetConnection.maxPeerConnections.
> the default is 8, but you can change it to anything.
}}}

this can influence the way we build "supergroup",<br>
for ex: a "command center" type of group would need to not rely at all on DIRECT_CONNECTIONS NetStreams<br>
and that's easy to solve, just use the NetGroup to communicate "command"s and that way no peer limits;<br>
but in the case of "using one group to share one file", there it would have a huge influence<br>
if we use NetStream then maxPeerConnections would be the limit of people who can leech/seed this file.


{{{
P2P permission dialog
  - Groups can use upload bandwidth for other membersâ€™ traffic
  - Must be accepted before groups will function
}}}

only happen with a SWF hosted with the Flash Player plugin (or from a standalone player)<br>
when in an AIR application, no permission dialog popup


== other ==

let's emit the theory that we could have server with unlimited possibility<br>
and could connect any amount of users with rendez-vous server<br>
<br>
how many Peer ID could be deal with ?

so a peer ID is [http://en.wikipedia.org/wiki/256-bit 256 bit], that means `2^256`<br>
from wikipedia

<pre>
Already 2^128 (128-bit) would greatly exceed the total data stored on Earth as of 2010,
which has been estimated to be around 1.2 zettabytes (over 2^70 bytes)
</pre>

We could also use the IP address as an example<br>
eg. `255.255.255.255` (which translate to 0xFFFFFFFF) in IPv4 is only *32 bits*<br>
and can deal with all servers,clients,etc. internet connection as of 2012.


== performance ==

A bit stupid, but if you use network/node/client etc. using protected override or hook functions<br>
you can test only with 5/6 instances of the client locally.

If you use Events to reroute/dispatch NetStatusEvent, then you can instantiate 20+ clients<br>
and everything react faster etc.


== visuals ==

Our main logic is to use a *CommandCenter* that connect all clients all the time<br>
and because each clients has a unique *Peer ID* even in different groups<br>
we can then map all those clients on a ring based on their unique Peer ID address.



